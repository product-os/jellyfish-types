#!/usr/bin/env node

/*
 * Copyright (C) Balena.io - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * Proprietary and confidential.
 */

/*
 * This script generates types from contract definitions.
 * Usage: ./scripts/generate-contract-types.js /path/to/contracts/index.ts
 */

const fs = require('fs');
const path = require('path');
const { compile } = require('json-schema-to-typescript');
const { filter, get, identity, sortBy } = require('lodash');

require('ts-node').register();

const bannerComment = `/*
 * Copyright (C) Balena.io - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * Proprietary and confidential.
 *
 * This file was automatically generated by 'npm run types'.
 *
 * DO NOT MODIFY IT BY HAND!
 */
`;

const typeInterfacePrefix = `
// tslint:disable: array-type
import { core } from '@balena/jellyfish-types';
`;

/**
 * Generates TypeScript interface definition files for any type contracts in the given list of contracts.
 * The generated files will be written to the outputDir directory, which will be deleted and re-created
 * as part of this function's actions.
 *
 * @param outputDir - the output directory into which interface definition files should be written
 * @param contracts - a list of contracts. An interface definition file will be generated for every
 *                    _type_ contract.
 */
async function generateContractInterfaces(outputDir, contracts) {
	let indexContent = bannerComment + typeInterfacePrefix;

	const sortedContracts = sortBy(contracts, 'slug');

	// Generate files
	const results = await Promise.all(
		sortedContracts
			.filter((contract) => {
				return contract.type === 'type@1.0.0';
			})
			.map(async (contract) => {
				// Not sure if we need to worry about anything other than "data".
				// Maybe include other fields whose definition differs from base Contract.
				const schema = get(
					contract,
					['data', 'schema', 'properties', 'data'],
					{},
				);
				schema.title = `${contract.slug}-data`;

				try {
					let compiled = await compile(schema, contract.slug, {
						ignoreMinAndMaxItems: true,
						unknownAny: true,
						style: {
							bracketSpacing: true,
							printWidth: 120,
							semi: true,
							singleQuote: true,
							tabWidth: 2,
							trailingComma: 'all',
							useTabs: true,
						},
					});
					const contractName = compiled.match(/interface ([a-zA-Z]+)Data/)?.[1];

					// Add definitions for the contract and contract defintion
					compiled += `
export interface ${contractName}ContractDefinition
	extends core.ContractDefinition<${contractName}Data> {}
export interface ${contractName}Contract
	extends core.Contract<${contractName}Data> {}
`;
					// Add an export to the index file
					indexContent += compiled;

					console.log(`Generated contract interface for ${contract.slug}`);
					return true;
				} catch (error) {
					console.log(`Could not create interface for ${contract.slug}`);
					return false;
				}
			}),
	);

	fs.mkdirSync(outputDir, { recursive: true });
	fs.writeFileSync(path.join(outputDir, 'types.ts'), indexContent);
	console.log(`Types written to ${path.join(outputDir, 'types.ts')}`);
	return results;
}

async function main() {
	const importPath = path.join(process.cwd(), process.argv[2]);
	console.log(`Generating types for contracts in ${importPath}`);

	const { default: cards } = require(importPath);

	const uiSchemaDef = (key) => {
		return `node_modules/@balena/jellyfish-core/build/cards/mixins/ui-schema-defs.json#/${key}`;
	};

	const contracts = cards.map((card) => {
		if (card instanceof Function) {
			return card({ mixin: (_) => (schema) => schema, uiSchemaDef });
		} else {
			return card;
		}
	});
	const results = await generateContractInterfaces(
		path.dirname(importPath),
		contracts,
	);
	const succeeded = filter(results, identity);
	console.log(
		`Generated ${succeeded.length} contract interfaces (${
			results.length - succeeded.length
		} failed)`,
	);
}

main().catch((err) => console.error(err));
