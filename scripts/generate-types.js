#!/usr/bin/env node

/*
 * Copyright (C) Balena.io - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * Proprietary and confidential.
 */

/*
 * This script generates types from contract definitions.
 * Check usage: ./scripts/generate-types.js --help
 */

const fs = require('fs');
const path = require('path');
const { compile } = require('json-schema-to-typescript');
const { filter, get, identity, sortBy } = require('lodash');

require('ts-node').register();

const argv = require('yargs/yargs')(process.argv.slice(2))
	.usage('Usage: $0 [options]')
	.example(
		'$0 -i lib/cards/index.ts',
		'generate types for cards exported from lib/cards/index.ts',
	)
	.alias('i', 'import')
	.describe('i', 'Path to file that exports contracts')
	.alias('m', 'mixins')
	.describe('m', 'List of package(s) that provides contract mixins')
	.default('m', '@balena/jellyfish-plugin-default,@balena/jellyfish-core')
	.demandOption(['i'])
	.help('h')
	.alias('h', 'help').argv;

const bannerComment = `/*
 * Copyright (C) Balena.io - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * Proprietary and confidential.
 *
 * This file was automatically generated by 'npm run types'.
 *
 * DO NOT MODIFY IT BY HAND!
 */
`;

const typeInterfacePrefix = `
// tslint:disable: array-type
import { core } from '@balena/jellyfish-types';
`;

/**
 * Generates TypeScript interface definition files for any type contracts in the given list of contracts.
 * The generated files will be written to the outputDir directory, which will be deleted and re-created
 * as part of this function's actions.
 *
 * @param outputDir - the output directory into which interface definition files should be written
 * @param contracts - a list of contracts. An interface definition file will be generated for every
 *                    _type_ contract.
 */
async function generateContractInterfaces(outputDir, contracts) {
	let indexContent = bannerComment + typeInterfacePrefix;
	const sortedContracts = sortBy(contracts, 'slug');

	// Generate files
	const results = await Promise.all(
		sortedContracts
			.filter((contract) => {
				return contract.type.split('@')[0] === 'type';
			})
			.map(async (contract) => {
				// Not sure if we need to worry about anything other than "data".
				// Maybe include other fields whose definition differs from base Contract.
				const schema = get(
					contract,
					['data', 'schema', 'properties', 'data'],
					{},
				);
				schema.title = `${contract.slug}-data`;

				try {
					let compiled = await compile(schema, contract.slug, {
						bannerComment: '',
						ignoreMinAndMaxItems: true,
						unknownAny: true,
						style: {
							bracketSpacing: true,
							printWidth: 120,
							semi: true,
							singleQuote: true,
							tabWidth: 2,
							trailingComma: 'all',
							useTabs: true,
						},
					});
					const contractName = compiled.match(/interface ([a-zA-Z]+)Data/)?.[1];

					// Add definitions for the contract and contract defintion
					compiled += `
export interface ${contractName}ContractDefinition
	extends core.ContractDefinition<${contractName}Data> {}
export interface ${contractName}Contract
	extends core.Contract<${contractName}Data> {}
`;
					// Add an export to the index file
					indexContent += compiled;

					return true;
				} catch (error) {
					console.log(`Could not create interface for ${contract.slug}`);
					return false;
				}
			}),
	);

	if (results.length > 0) {
		fs.mkdirSync(outputDir, { recursive: true });
		fs.writeFileSync(path.join(outputDir, 'types.ts'), indexContent);
		console.log(`Types written to ${path.join(outputDir, 'types.ts')}`);
	}
	return results;
}

async function main() {
	const importPath = path.join(process.cwd(), argv.import);
	console.log(`Generating types for contracts in ${importPath}`);
	console.log('Note: This tool currently only works for type contracts');

	// Import mixins
	let mixins = {};
	argv.mixins.split(',').forEach((package) => {
		const { cardMixins } = require(package);
		mixins = {
			...mixins,
			...cardMixins,
		};
	});

	// Import contracts
	const imported = require(importPath);
	const list = imported[Object.keys(imported)[0]];

	const contracts = list.map((card) => {
		if (card instanceof Function) {
			return card(mixins);
		} else {
			return card;
		}
	});
	const results = await generateContractInterfaces(
		path.dirname(importPath),
		contracts,
	);
	const succeeded = filter(results, identity);
	console.log(
		`Generated ${succeeded.length} contract interfaces (${
			results.length - succeeded.length
		} failed)`,
	);
}

main().catch((err) => console.error(err));
